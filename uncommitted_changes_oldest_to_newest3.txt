








import { ApiProperty } from '@nestjs/swagger';
import { Transform, Type } from 'class-transformer';
import { IsBoolean, IsEnum, IsOptional, IsString } from 'class-validator';
import { AssetOrder, AssetType, TimeBucketSize } from 'src/enum';
import { ValidateUUID } from 'src/validators';

export class TimeBucketDto {
  @IsOptional()
  @ValidateUUID()
  @ApiProperty({ type: 'string' })
  albumId?: string;

  @IsOptional()
  @IsBoolean()
  @Type(() => Boolean)
  @ApiProperty()
  withStacked?: boolean;
  @IsOptional()
  @IsBoolean()
  @Type(() => Boolean)
  @ApiProperty()
  @IsOptional()
  @IsBoolean()
  @Type(() => Boolean)
  @ApiProperty()
  @IsOptional()
  @IsBoolean()
  @Type(() => Boolean)
  @ApiProperty()
  @IsOptional()
  @IsBoolean()
  @Type(() => Boolean)
  @ApiProperty()
  @IsOptional()
  @ApiProperty({ enum: AssetOrder })
  @IsOptional()
  @IsEnum(TimeBucketSize)
  @Transform(({ value }) => (typeof value === 'string' ? value.toUpperCase() : value))
  @ApiProperty({ enum: TimeBucketSize })
  size?: TimeBucketSize;

  @IsOptional()
  @IsEnum(AssetType)
  @ApiProperty({ enum: AssetType })
  assetType?: AssetType;

  @IsOptional()
  @ValidateUUID()
  @ApiProperty({ type: 'string' })
  userId?: string;

  @IsOptional()
  @ValidateUUID()
  @ApiProperty({ type: 'string' })
  personId?: string;

  @IsOptional()
  @ApiProperty()
  key?: string;
  @IsOptional()
  @ValidateUUID()
  tagId?: string;

  @IsOptional()
  @ValidateUUID({ each: true, optional: true })
  @ApiProperty({ type: 'string', isArray: true })
  tagIds?: string[];
  @IsOptional()
  @IsBoolean()
  @Type(() => Boolean)
  @ApiProperty()
  isDuplicate?: boolean;
}
++ b/server/src/repositories/asset.repository.ts
  tagIds?: string[];
  tagIds?: string[]; // Add it here if not in AssetBuilderOptions













  async getByAlbumId(
    albumId: string, 
    options: {
      order?: AssetOrder;
      tagIds?: string[];
      isFavorite?: boolean;
    } = {},
    pagination: PaginationOptions = { take: 100 }
  ): Paginated<AssetEntity> {
    console.log("Album ID:", albumId);
    console.log("Filter options:", JSON.stringify(options));
    
    let query = withAlbums(this.db.selectFrom('assets'), { albumId })
      .selectAll('assets')
      .where('deletedAt', 'is', null);


    if (options.tagIds && options.tagIds.length > 0) {
      query = query.where(eb => {
        return eb.exists(
          eb.selectFrom('asset_tags')
            .select(1)
            .whereRef('asset_tags.assetId', '=', 'assets.id')
            .where('asset_tags.tagId', 'in', options.tagIds)
        );
      });
    }
    
    
    if (options.isFavorite !== undefined) {
      query = query.where('assets.isFavorite', '=', options.isFavorite);
      console.log("SQL favorite filtering applied:", options.isFavorite);
    }
    
    if (options.order === AssetOrder.NEWEST) {
      query = query.orderBy('assets.fileCreatedAt', 'desc');
    } else if (options.order === AssetOrder.OLDEST) {
      query = query.orderBy('assets.fileCreatedAt', 'asc');
    } else {
      query = query.orderBy('assets.fileCreatedAt', 'desc');
    }
  
    console.log("Generated SQL query:", query.toSQL ? query.toSQL() : "SQL query not available");
    
    const items = await query.execute();
    console.log(`Found ${items.length} assets after filtering`);
    













async getTimeBuckets(options: TimeBucketOptions): Promise<TimeBucketItem[]> {
  return (
    this.db
      .with('assets', (qb) =>
          .selectFrom('assets')
          .select(truncatedDate<Date>(options.size).as('timeBucket'))
          .$if(!!options.isTrashed, (qb) => qb.where('assets.status', '!=', AssetStatus.DELETED))
          .where('assets.deletedAt', options.isTrashed ? 'is not' : 'is', null)
          .where('assets.isVisible', '=', true)
          .where('assets.fileCreatedAt', 'is not', null)
          .where('assets.fileModifiedAt', 'is not', null)
          .where('assets.localDateTime', 'is not', null)
          .$if(!!options.albumId, (qb) =>
            qb
              .innerJoin('albums_assets_assets', 'assets.id', 'albums_assets_assets.assetsId')
              .where('albums_assets_assets.albumsId', '=', asUuid(options.albumId!)),
          .$if(!!options.personId, (qb) => hasPeople(qb, [options.personId!]))
          .$if(!!options.withStacked, (qb) =>
            qb
              .leftJoin('asset_stack', (join) =>
                join
                  .onRef('asset_stack.id', '=', 'assets.stackId')
                  .onRef('asset_stack.primaryAssetId', '=', 'assets.id'),
              )
              .where((eb) => eb.or([eb('assets.stackId', 'is', null), eb(eb.table('asset_stack'), 'is not', null)])),
          .$if(!!options.userIds, (qb) => qb.where('assets.ownerId', '=', anyUuid(options.userIds!)))
          .$if(options.isArchived !== undefined, (qb) => qb.where('assets.isArchived', '=', options.isArchived!))
          .$if(options.isFavorite !== undefined, (qb) => qb.where('assets.isFavorite', '=', options.isFavorite!))
          .$if(!!options.assetType, (qb) => qb.where('assets.type', '=', options.assetType!))
          .$if(options.isDuplicate !== undefined, (qb) =>
            qb.where('assets.duplicateId', options.isDuplicate ? 'is not' : 'is', null),
          )
          .$if(!!options.tagId, (qb) => withTagId(qb, options.tagId!))
          .$if(!!options.tagIds && options.tagIds.length > 0, (qb) => {
            console.log("Filtering timeline buckets by tagIds:", options.tagIds);
            return qb.where(eb => {
              return eb.exists(
                eb.selectFrom('asset_tags')
                  .select(1)
                  .whereRef('asset_tags.assetId', '=', 'assets.id')
                  .where('asset_tags.tagId', 'in', options.tagIds!)
              );
            });
          })
      .selectFrom('assets')
      .select('timeBucket')
      TODO: the above line outputs in ISO format, which bloats the response.
      The line below outputs in YYYY-MM-DD format, but needs a change in the web app to work.
        .select(sql<string>`"timeBucket"::date::text`.as('timeBucket'))
      */
      .select((eb) => eb.fn.countAll<number>().as('count'))
      .groupBy('timeBucket')
      .orderBy('timeBucket', options.order ?? 'desc')
      .execute() as any as Promise<TimeBucketItem[]>
  );
}
















@GenerateSql({ params: [DummyValue.TIME_BUCKET, { size: TimeBucketSize.MONTH, withStacked: true }] })
async getTimeBucket(timeBucket: string, options: TimeBucketOptions): Promise<AssetEntity[]> {
  return this.db
    .selectFrom('assets')
    .selectAll('assets')
    .$call(withExif)
    .$if(!!options.albumId, (qb) => withAlbums(qb, { albumId: options.albumId }))
    .$if(!!options.personId, (qb) => hasPeople(qb, [options.personId!]))
    .$if(!!options.userIds, (qb) => qb.where('assets.ownerId', '=', anyUuid(options.userIds!)))
    .$if(options.isArchived !== undefined, (qb) => qb.where('assets.isArchived', '=', options.isArchived!))
    .$if(options.isFavorite !== undefined, (qb) => qb.where('assets.isFavorite', '=', options.isFavorite!))
    .$if(!!options.withStacked, (qb) =>
      qb
        .leftJoin('asset_stack', 'asset_stack.id', 'assets.stackId')
        .where((eb) =>
          eb.or([eb('asset_stack.primaryAssetId', '=', eb.ref('assets.id')), eb('assets.stackId', 'is', null)]),
        )
        .leftJoinLateral(
          (eb) =>
            eb
              .selectFrom('assets as stacked')
              .selectAll('asset_stack')
              .select((eb) => eb.fn.count(eb.table('stacked')).as('assetCount'))
              .whereRef('stacked.stackId', '=', 'asset_stack.id')
              .where('stacked.deletedAt', 'is', null)
              .where('stacked.isArchived', '=', false)
              .groupBy('asset_stack.id')
              .as('stacked_assets'),
          (join) => join.on('asset_stack.id', 'is not', null),
        )
        .select((eb) => eb.fn.toJson(eb.table('stacked_assets')).as('stack')),
    )
    .$if(!!options.assetType, (qb) => qb.where('assets.type', '=', options.assetType!))
    .$if(options.isDuplicate !== undefined, (qb) =>
      qb.where('assets.duplicateId', options.isDuplicate ? 'is not' : 'is', null),
    )
    .$if(!!options.isTrashed, (qb) => qb.where('assets.status', '!=', AssetStatus.DELETED))
    .$if(!!options.tagId, (qb) => withTagId(qb, options.tagId!))
    .$if(!!options.tagIds && options.tagIds.length > 0, (qb) => {
      console.log("Filtering timeline bucket by tagIds:", options.tagIds);
      return qb.where(eb => {
        return eb.exists(
          eb.selectFrom('asset_tags')
            .select(1)
            .whereRef('asset_tags.assetId', '=', 'assets.id')
            .where('asset_tags.tagId', 'in', options.tagIds!)
        );
      });
    })
    .where('assets.deletedAt', options.isTrashed ? 'is not' : 'is', null)
    .where('assets.isVisible', '=', true)
    .where(truncatedDate(options.size), '=', timeBucket.replace(/^[+-]/, ''))
    .orderBy('assets.localDateTime', options.order ?? 'desc')
    .execute() as any as Promise<AssetEntity[]>;
}


















++ b/server/src/services/timeline.service.ts
import { AssetBuilderOptions, TimeBucketOptions } from 'src/repositories/asset.repository';
    const options: TimeBucketOptions = { ...dto };
  
    if (dto.userId) {
      userIds = [dto.userId];
      
      options.userIds = userIds;
    if (dto.tagIds && dto.tagIds.length > 0) {
      options.tagIds = dto.tagIds;
      console.log("Including tagIds in timeline options:", dto.tagIds);
    }
  
    return options;
    
    if (dto.tagIds && dto.tagIds.length > 0) {
      await this.requireAccess({ auth, permission: Permission.TAG_READ, ids: dto.tagIds });
    }
}
++ b/web/src/lib/components/asset-viewer/asset-viewer.svelte
    <!-- commented out this 888999888 and added line 461 <div class="z-[1001] my-auto column-span-1 col-start-1 row-span-full row-start-1 justify-self-start"> -->
    <div class="z-[1001] fixed left-[0%] bottom-[10%]">
    <!-- <div class="z-[1001] my-auto col-span-1 col-start-4 row-span-full row-start-1 justify-self-end"> -->
    <div class="z-[1001] fixed left-[20%] bottom-[88%]">
++ b/web/src/lib/components/asset-viewer/video-native-viewer.svelte
<!-- 
    <script lang="ts">
      import LoadingSpinner from '$lib/components/shared-components/loading-spinner.svelte';
      import { loopVideo as loopVideoPreference, videoViewerMuted, videoViewerVolume } from '$lib/stores/preferences.store';
      import { getAssetPlaybackUrl, getAssetThumbnailUrl } from '$lib/utils';
      import { handleError } from '$lib/utils/handle-error';
      import { AssetMediaSize } from '@immich/sdk';
      import { onDestroy, onMount } from 'svelte';
      import { swipe } from 'svelte-gestures';
      import type { SwipeCustomEvent } from 'svelte-gestures';
      import { fade } from 'svelte/transition';
      import { t } from 'svelte-i18n';
      import { isFaceEditMode } from '$lib/stores/face-edit.svelte';
      import FaceEditor from '$lib/components/asset-viewer/face-editor/face-editor.svelte';
      
      import Icon from '$lib/components/elements/icon.svelte';
      import TagAssetForm from '$lib/components/forms/tag-asset-form.svelte';
      import Portal from '$lib/components/shared-components/portal/portal.svelte';
      import { AppRoute } from '$lib/constants';
      import { isSharedLink } from '$lib/utils';
      import { removeTag, tagAssets } from '$lib/utils/asset-utils';
      import { getAssetInfo, type AssetResponseDto, getAllTags } from '@immich/sdk';
      import { mdiClose, mdiPlus, mdiTag } from '@mdi/js';
    
      interface Props {
        assetId: string;
        loopVideo: boolean;
        cacheKey: string | null;
        skipPercentage?: number; // Skip percentage of total video duration
        maxSkipSeconds?: number; // Maximum skip time in seconds
        minSkipSeconds?: number; // Minimum skip time in seconds
        asset?: AssetResponseDto; // Added asset property
        isOwner?: boolean; // Added isOwner property
        onPreviousAsset?: () => void;
        onNextAsset?: () => void;
        onVideoEnded?: () => void;
        onVideoStarted?: () => void;
        onClose?: () => void;
    
      let {
        assetId,
        loopVideo,
        cacheKey,
        skipPercentage = 0.1, // Default to 20% of video duration
        maxSkipSeconds = 1, // Default max skip of 10 seconds
        minSkipSeconds = 1, // Default min skip of 2 seconds
        asset = $bindable(),
        isOwner = true,
        onPreviousAsset = () => {},
        onNextAsset = () => {},
        onVideoEnded = () => {},
        onVideoStarted = () => {},
        onClose = () => {},
      }: Props = $props();
    
      let videoPlayer: HTMLVideoElement | undefined = $state();
      let isLoading = $state(true);
      let assetFileUrl = $state('');
      let forceMuted = $state(false);
      let isScrubbing = $state(false);
      
      let skipForwardInterval: number | null = $state(null);
      let skipBackwardInterval: number | null = $state(null);
      let skipIntervalDelay = 470; // Milliseconds between skips when holding
      
      let currentTime = $state(0);
      let duration = $state(0);
      let progress = $state(0);
      let isProgressBarHovered = $state(false);
      let showControls = $state(true);
      let controlsTimeout: number | null = $state(null);
    
      let tags = $derived(asset?.tags || []);
      let isTagFormOpen = $state(false);
      let showTagsPanel = $state(false);
      
      const presetTags = [
      { id: 'preset-low', value: 'low' },
      { id: 'preset-semitop', value: 'semitop' },
      { id: 'preset-top', value: 'top' },
      { id: 'preset-lowTOK', value: 'lowTOK' },
      { id: 'preset-semiTOK', value: 'semiTOK' },
      { id: 'preset-topTOK', value: 'topTOK' },
      { id: 'preset-twerk', value: 'twerk' },
      { id: 'preset-face', value: 'face' },
      { id: 'preset-wiggle', value: 'wiggle' },
      { id: 'preset-pose', value: 'pose' },
      { id: 'preset-recoil', value: 'recoil' },
      { id: 'preset-ass', value: 'ass' },
      { id: 'preset-walk', value: 'walk' },
      { id: 'preset-lay', value: 'lay' },
      { id: 'preset-tongue', value: 'tongue' },
      { id: 'preset-ahegao', value: 'ahegao' },
      { id: 'preset-editing', value: 'editing' },
      { id: 'preset-tit', value: 'tit' }
    ];
      
      let availableTagsMap = $state<Record<string, string>>({});
      
      let selectedPresetTags = $state<string[]>([]);
    
      onMount(async () => {
        if (videoPlayer) {
          assetFileUrl = getAssetPlaybackUrl({ id: assetId, cacheKey });
          forceMuted = false;
          videoPlayer.load();
        }
        
        if (!asset?.id && assetId) {
          try {
            asset = await getAssetInfo({ id: assetId });
          } catch (error) {
            handleError(error, $t('errors.unable_to_load_asset_info'));
          }
        }
        
        if (asset?.tags) {
          selectedPresetTags = asset.tags
            .filter(tag => presetTags.some(preset => preset.value === tag.value))
            .map(tag => tag.value);
        }
        
        try {
          const allTags = await getAllTags();
          
          availableTagsMap = allTags.reduce((map: Record<string, string>, tag) => {
            map[tag.value.toLowerCase()] = tag.id;
            return map;
          }, {});
        } catch (error) {
          handleError(error, $t('errors.unable_to_load_tags'));
        }
        
        controlsTimeout = setTimeout(() => {
          showControls = false;
        }, 3000);
      });
    
      onDestroy(() => {
        if (videoPlayer) {
          videoPlayer.src = '';
        }
        clearHoldIntervals();
        
        if (controlsTimeout) {
          clearTimeout(controlsTimeout);
        }
      });
    
      const clearHoldIntervals = () => {
        if (skipForwardInterval) {
          clearInterval(skipForwardInterval);
          skipForwardInterval = null;
        }
        if (skipBackwardInterval) {
          clearInterval(skipBackwardInterval);
          skipBackwardInterval = null;
        }
      };
    
      const handleCanPlay = async (video: HTMLVideoElement) => {
        try {
          if (!video.paused && !isScrubbing) {
            await video.play();
            onVideoStarted();
          }
        } catch (error) {
          if (error instanceof DOMException && error.name === 'NotAllowedError' && !forceMuted) {
            await tryForceMutedPlay(video);
            return;
          }
    
          handleError(error, $t('errors.unable_to_play_video'));
        } finally {
          isLoading = false;
        }
      };
    
      const tryForceMutedPlay = async (video: HTMLVideoElement) => {
        try {
          video.muted = true;
          await handleCanPlay(video);
        } catch (error) {
          handleError(error, $t('errors.unable_to_play_video'));
        }
      };
    
      const onSwipe = (event: SwipeCustomEvent) => {
        if (event.detail.direction === 'left') {
          onNextAsset();
        }
        if (event.detail.direction === 'right') {
          onPreviousAsset();
        }
      };
    
      const calculateSkipTime = () => {
        if (!videoPlayer) return 0;
        
        let skipTime = videoPlayer.duration * skipPercentage;
        
        if (skipTime > maxSkipSeconds) {
          skipTime = maxSkipSeconds;
        } else if (skipTime < minSkipSeconds) {
          skipTime = minSkipSeconds;
        }
        
        return skipTime;
      };
    
      const skipForward = () => {
        if (!videoPlayer) return;
        
        const skipTime = calculateSkipTime();
        const newTime = Math.min(videoPlayer.currentTime + skipTime, videoPlayer.duration);
        videoPlayer.currentTime = newTime;
      };
    
      const skipBackward = () => {
        if (!videoPlayer) return;
        
        const skipTime = calculateSkipTime();
        const newTime = Math.max(videoPlayer.currentTime - skipTime, 0);
        videoPlayer.currentTime = newTime;
      };
    
      const startForwardSkip = () => {
        if (skipForwardInterval) return; // Already skipping
        
        skipForward();
        
        skipForwardInterval = setInterval(() => {
          skipForward();
        }, skipIntervalDelay);
      };
    
      const stopForwardSkip = () => {
        if (skipForwardInterval) {
          clearInterval(skipForwardInterval);
          skipForwardInterval = null;
        }
      };
    
      const startBackwardSkip = () => {
        if (skipBackwardInterval) return; // Already skipping
        
        skipBackward();
        
        skipBackwardInterval = setInterval(() => {
          skipBackward();
        }, skipIntervalDelay);
      };
    
      const stopBackwardSkip = () => {
        if (skipBackwardInterval) {
          clearInterval(skipBackwardInterval);
          skipBackwardInterval = null;
        }
      };
    
      const handleKeydown = (event: KeyboardEvent) => {
        if (event.key === 'ArrowRight') {
          skipForward();
          event.preventDefault();
        }
        else if (event.key === 'ArrowLeft') {
          skipBackward();
          event.preventDefault();
        }
      };
      
      const updateProgress = () => {
        if (!videoPlayer) return;
        currentTime = videoPlayer.currentTime;
        duration = videoPlayer.duration || 0;
        progress = duration ? (currentTime / duration) * 100 : 0;
      };
      
      const handleProgressBarClick = (event: MouseEvent) => {
        if (!videoPlayer) return;
        const progressBar = event.currentTarget as HTMLDivElement;
        const rect = progressBar.getBoundingClientRect();
        const clickPosition = (event.clientX - rect.left) / rect.width;
        videoPlayer.currentTime = clickPosition * videoPlayer.duration;
      };
      
      const togglePlayPause = () => {
        if (!videoPlayer) return;
        if (videoPlayer.paused) {
          videoPlayer.play();
        } else {
          videoPlayer.pause();
        }
        
        showControls = true;
        resetControlsTimeout();
      };
      
      const formatTime = (timeInSeconds: number): string => {
        if (isNaN(timeInSeconds)) return '00:00';
        
        const minutes = Math.floor(timeInSeconds / 60);
        const seconds = Math.floor(timeInSeconds % 60);
        
        return `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
      };
      
      const resetControlsTimeout = () => {
        if (controlsTimeout) {
          clearTimeout(controlsTimeout);
        }
        
        controlsTimeout = setTimeout(() => {
          showControls = false;
        }, 3000);
      };
      
      const showVideoControls = () => {
        showControls = true;
        resetControlsTimeout();
      };
    
      const toggleTagsPanel = () => {
        showTagsPanel = !showTagsPanel;
      };
    
      const handleAddTag = () => (isTagFormOpen = true);
    
      const handleCancelTag = () => (isTagFormOpen = false);
    
      const handleTag = async (tagIds: string[]) => {
        if (!asset?.id) return;
        
        const ids = await tagAssets({ tagIds, assetIds: [asset.id], showNotification: false });
        if (ids) {
          isTagFormOpen = false;
        }
    
        asset = await getAssetInfo({ id: asset.id });
        
        if (asset?.tags) {
          selectedPresetTags = asset.tags
            .filter(tag => presetTags.some(preset => preset.value === tag.value))
            .map(tag => tag.value);
        }
      };
    
      const handleRemoveTag = async (tagId: string) => {
        if (!asset?.id) return;
        
        const ids = await removeTag({ tagIds: [tagId], assetIds: [asset.id], showNotification: false });
        if (ids) {
          asset = await getAssetInfo({ id: asset.id });
          
          if (asset?.tags) {
            selectedPresetTags = asset.tags
              .filter(tag => presetTags.some(preset => preset.value === tag.value))
              .map(tag => tag.value);
          }
        }
      };
      
      const togglePresetTag = async (presetTagValue: string) => {
        if (!asset?.id) return;
        
        const existingTag = asset.tags.find(tag => tag.value === presetTagValue);
        
        if (existingTag) {
          await handleRemoveTag(existingTag.id);
        } else {
          
          const tagId = availableTagsMap[presetTagValue.toLowerCase()];
          
          if (tagId) {
            await handleTag([tagId]);
          } else {
            isTagFormOpen = true;
          }
        }
      };
      
      const isPresetTagSelected = (tagValue: string): boolean => {
        return asset?.tags?.some(tag => tag.value === tagValue) || false;
      };
    
      let containerWidth = $state(0);
      let containerHeight = $state(0);
    
      $effect(() => {
        if (isFaceEditMode.value) {
          videoPlayer?.pause();
        }
      });
    </script>
    
    <div
      transition:fade={{ duration: 150 }}
      class="flex flex-col h-full select-none"
    >
      <div 
        class="flex-grow relative flex place-content-center place-items-center"
        bind:clientWidth={containerWidth}
        bind:clientHeight={containerHeight}
        onkeydown={handleKeydown}
        tabindex="0"
        onmousemove={showVideoControls}
        ontouchmove={showVideoControls}
      >
        <video
          bind:this={videoPlayer}
          loop={$loopVideoPreference && loopVideo}
          autoplay
          playsinline
          webkit-playsinline="true"
          class="h-full object-contain"
          use:swipe={() => ({})}
          onswipe={onSwipe}
          ontimeupdate={updateProgress}
          oncanplay={(e) => handleCanPlay(e.currentTarget)}
          onended={onVideoEnded}
          onvolumechange={(e) => {
            if (!forceMuted) {
              $videoViewerMuted = e.currentTarget.muted;
            }
          }}
          onseeking={() => (isScrubbing = true)}
          onseeked={() => (isScrubbing = false)}
          onplaying={(e) => {
            e.currentTarget.focus();
            updateProgress();
          }}
          onclose={() => onClose()}
          muted={forceMuted || $videoViewerMuted}
          bind:volume={$videoViewerVolume}
          poster={getAssetThumbnailUrl({ id: assetId, size: AssetMediaSize.Preview, cacheKey })}
          src={assetFileUrl}
          onclick={togglePlayPause}
        >
        </video>
    
        {#if isLoading}
          <div class="absolute flex place-content-center place-items-center">
            <LoadingSpinner />
          </div>
        {/if}
    
        {#if isFaceEditMode.value}
          <FaceEditor htmlElement={videoPlayer} {containerWidth} {containerHeight} {assetId} />
        {/if}
    
        <!-- Skip Backward Button with hold functionality
        <div class="z-[1001] fixed left-0 bottom-[15%]">
          <button 
            class="bg-transparent text-white rounded-full p-2"
            onmousedown={startBackwardSkip}
            onmouseup={stopBackwardSkip}
            onmouseleave={stopBackwardSkip}
            ontouchstart={startBackwardSkip}
            ontouchend={stopBackwardSkip}
          >
            ⏪ Skip
          </button>
        </div>
    
        <!-- Skip Forward Button with hold functionality 
        <div class="z-[1001] fixed left-0 bottom-[88%]">
          <button 
            class="bg-transparent text-white rounded-full p-2"
            onmousedown={startForwardSkip}
            onmouseup={stopForwardSkip}
            onmouseleave={stopForwardSkip}
            ontouchstart={startForwardSkip}
            ontouchend={stopForwardSkip}
          >
            Skip ⏩
          </button>
        </div>
        
    <!-- Preset Tags Quick Access Panel - Left side of the video 
    {#if isOwner && asset?.id && !isSharedLink()}
    <div class="z-[1001] fixed left-2 bottom-77">
      <div class="flex flex-col gap-1">
        {#each presetTags as presetTag (presetTag.id)}
        <button
        type="button"
        class={`px-2 py-1 rounded-lg text-white text-opacity-50 transition-all flex items-center gap-1 ${isPresetTagSelected(presetTag.value) ? 'bg-immich-primary' : 'bg-black bg-opacity-5 hover:bg-immich-primary/50'}`}
        onclick={() => togglePresetTag(presetTag.value)}
      >
        <Icon path={mdiTag} size="0.6rem" />
        <span class="text-xs font-medium text-opacity-50">{presetTag.value}</span>
      </button>
        {/each}
      </div>
    </div>
  {/if}
        
        <!-- Custom progress bar - shows only when showControls is true 
        {#if showControls}
          <div 
          class="absolute bottom-0 left-0 right-0 bg-black bg-opacity-40 px-2 py-1 transition-opacity mx-auto max-w-[80%]"
          transition:fade={{ duration: 150 }}
          >
            <div 
              class="relative h-2 bg-gray-600 rounded cursor-pointer"
              onmousedown={handleProgressBarClick}
              ontouchstart={handleProgressBarClick}
            >
              <div 
                class="absolute top-0 left-0 h-full bg-immich-primary rounded"
                style={`width: ${progress}%`}
              ></div>
            </div>
            
            <!-- Time indicator 
            <div class="flex justify-between text-xs text-white mt-1">
              <span>{formatTime(currentTime)}</span>
              <span>{formatTime(duration)}</span>
            </div>
          </div>
        {/if}
    
        <!-- Tag Button and Panel section 
        {#if isOwner && asset?.id && !isSharedLink()}
          <div class="z-[1001] fixed left-0 bottom-[80%]">
            <div class="flex flex-col">
              <!-- Always visible add tag button 
              <button
                type="button"
                class="bg-immich-primary text-white rounded-full px-3 py-1 mb-2 flex items-center gap-1 hover:bg-immich-primary/80 transition-all"
                title="Add tag"
                onclick={handleAddTag}
              >
                <Icon path={mdiPlus} size="0.75rem" />
                <span class="text-xs">Add Tag</span>
              </button>
              
              <!-- Toggle for existing tags 
              {#if tags.length > 0}
              <button 
              type="button"
              class="bg-black bg-opacity-40 text-white text-opacity-5 rounded-full px-3 py-1 mb-2 flex items-center gap-1"
              title="Toggle Tags"
              onclick={toggleTagsPanel}
            >
              <span class="text-xs text-opacity-5">View Tags {showTagsPanel ? '▲' : '▼'}</span>
            </button>
              {/if}
              
              {#if showTagsPanel && tags.length > 0}
                <!-- Reduced max-width from 300px to 200px 
                <div class="bg-black bg-opacity-5 rounded p-2 max-w-[200px]">
                  <div class="flex flex-wrap gap-1">
                    {#each tags as tag (tag.id)}
                      <div class="flex group transition-all">
                        <a
                          class="inline-block h-min whitespace-nowrap pl-2 pr-1 py-0.5 text-center align-baseline leading-none text-gray-100 bg-immich-primary rounded-tl-full rounded-bl-full hover:bg-immich-primary/80 transition-all"
                          href={encodeURI(`${AppRoute.TAGS}/?path=${tag.value}`)}
                        >
                        <p class="text-xs text-opacity-50">
                          {tag.value}
                        </p>
                        </a>
    
                        <button
                          type="button"
                          class="text-gray-100 bg-immich-primary/95 rounded-tr-full rounded-br-full place-items-center place-content-center pr-1 pl-0.5 py-0.5 hover:bg-immich-primary/80 transition-all"
                          title="Remove tag"
                          onclick={() => handleRemoveTag(tag.id)}
                        >
                          <Icon path={mdiClose} size="0.75rem" />
                        </button>
                      </div>
                    {/each}
                  </div>
                </div>
              {/if}
            </div>
          </div>
        {/if}
      </div>
    </div>
    
    {#if isTagFormOpen}
      <Portal>
        <TagAssetForm onTag={(tagsIds) => handleTag(tagsIds)} onCancel={handleCancelTag} />
      </Portal>
    {/if} -->
    <script lang="ts">
      import LoadingSpinner from '$lib/components/shared-components/loading-spinner.svelte';
      import { loopVideo as loopVideoPreference, videoViewerMuted, videoViewerVolume } from '$lib/stores/preferences.store';
      import { getAssetPlaybackUrl, getAssetThumbnailUrl } from '$lib/utils';
      import { handleError } from '$lib/utils/handle-error';
      import { AssetMediaSize } from '@immich/sdk';
      import { onDestroy, onMount } from 'svelte';
      import { swipe } from 'svelte-gestures';
      import type { SwipeCustomEvent } from 'svelte-gestures';
      import { fade } from 'svelte/transition';
      import { t } from 'svelte-i18n';
      import { isFaceEditMode } from '$lib/stores/face-edit.svelte';
      import FaceEditor from '$lib/components/asset-viewer/face-editor/face-editor.svelte';
      
      import Icon from '$lib/components/elements/icon.svelte';
      import TagAssetForm from '$lib/components/forms/tag-asset-form.svelte';
      import Portal from '$lib/components/shared-components/portal/portal.svelte';
      import { AppRoute } from '$lib/constants';
      import { isSharedLink } from '$lib/utils';
      import { removeTag, tagAssets } from '$lib/utils/asset-utils';
      import { getAssetInfo, type AssetResponseDto, getAllTags } from '@immich/sdk';
      import { mdiClose, mdiPlus, mdiTag } from '@mdi/js';
    
      interface Props {
        assetId: string;
        loopVideo: boolean;
        cacheKey: string | null;
        skipPercentage?: number; // Skip percentage of total video duration
        maxSkipSeconds?: number; // Maximum skip time in seconds
        minSkipSeconds?: number; // Minimum skip time in seconds
        asset?: AssetResponseDto; // Added asset property
        isOwner?: boolean; // Added isOwner property
        onPreviousAsset?: () => void;
        onNextAsset?: () => void;
        onVideoEnded?: () => void;
        onVideoStarted?: () => void;
        onClose?: () => void;
    
      let {
        assetId,
        loopVideo,
        cacheKey,
        skipPercentage = 0.1, // Default to 10% of video duration
        maxSkipSeconds = 1, // Default max skip of 1 second
        minSkipSeconds = 1, // Default min skip of 1 second
        asset = $bindable(),
        isOwner = true,
        onPreviousAsset = () => {},
        onNextAsset = () => {},
        onVideoEnded = () => {},
        onVideoStarted = () => {},
        onClose = () => {},
      }: Props = $props();
    
      let videoPlayer: HTMLVideoElement | undefined = $state();
      let isLoading = $state(true);
      let assetFileUrl = $state('');
      let forceMuted = $state(false);
      let isScrubbing = $state(false);
      
      let normalPlaybackRate = 1.0;
      let fastForwardRate = 3.5; // 3.5x speed for fast forward
      let fastRewindRate = -3.5; // Negative value indicates we need to handle rewind specially
      let isForwarding = $state(false);
      let isRewinding = $state(false);
      let rewindInterval: number | null = $state(null); // For manual rewinding
      
      let currentTime = $state(0);
      let duration = $state(0);
      let progress = $state(0);
      let isProgressBarHovered = $state(false);
      let showControls = $state(true);
      let controlsTimeout: number | null = $state(null);
    
      let tags = $derived(asset?.tags || []);
      let isTagFormOpen = $state(false);
      let showTagsPanel = $state(false);
      
      const presetTags = [
        { id: 'preset-low', value: 'low' },
        { id: 'preset-semitop', value: 'semitop' },
        { id: 'preset-top', value: 'top' },
        { id: 'preset-lowTOK', value: 'lowTOK' },
        { id: 'preset-semiTOK', value: 'semiTOK' },
        { id: 'preset-topTOK', value: 'topTOK' },
        { id: 'preset-twerk', value: 'twerk' },
        { id: 'preset-face', value: 'face' },
        { id: 'preset-wiggle', value: 'wiggle' },
        { id: 'preset-pose', value: 'pose' },
        { id: 'preset-recoil', value: 'recoil' },
        { id: 'preset-spin', value: 'spin' },
        { id: 'preset-ass', value: 'ass' },
        { id: 'preset-walk', value: 'walk' },
        { id: 'preset-tongue', value: 'tongue' },
        { id: 'preset-ahegao', value: 'ahegao' },
        { id: 'preset-editing', value: 'editing' },
        { id: 'preset-tit', value: 'tit' }
      ];
      
      let availableTagsMap = $state<Record<string, string>>({});
      
      let selectedPresetTags = $state<string[]>([]);
    
      onMount(async () => {
        if (videoPlayer) {
          assetFileUrl = getAssetPlaybackUrl({ id: assetId, cacheKey });
          forceMuted = false;
          videoPlayer.load();
        }
        
        if (!asset?.id && assetId) {
          try {
            asset = await getAssetInfo({ id: assetId });
          } catch (error) {
            handleError(error, $t('errors.unable_to_load_asset_info'));
          }
        }
        
        if (asset?.tags) {
          selectedPresetTags = asset.tags
            .filter(tag => presetTags.some(preset => preset.value === tag.value))
            .map(tag => tag.value);
        }
        
        try {
          const allTags = await getAllTags();
          
          availableTagsMap = allTags.reduce((map: Record<string, string>, tag) => {
            map[tag.value.toLowerCase()] = tag.id;
            return map;
          }, {});
        } catch (error) {
          handleError(error, $t('errors.unable_to_load_tags'));
        }
        
        controlsTimeout = setTimeout(() => {
          showControls = false;
        }, 3000);
      });
    
      onDestroy(() => {
        if (videoPlayer) {
          videoPlayer.src = '';
        }
        if (rewindInterval) {
          clearInterval(rewindInterval);
        }
        
        if (controlsTimeout) {
          clearTimeout(controlsTimeout);
        }
      });
    
      const handleCanPlay = async (video: HTMLVideoElement) => {
        try {
          if (!video.paused && !isScrubbing) {
            await video.play();
            onVideoStarted();
          }
        } catch (error) {
          if (error instanceof DOMException && error.name === 'NotAllowedError' && !forceMuted) {
            await tryForceMutedPlay(video);
            return;
          }
    
          handleError(error, $t('errors.unable_to_play_video'));
        } finally {
          isLoading = false;
        }
      };
    
      const tryForceMutedPlay = async (video: HTMLVideoElement) => {
        try {
          video.muted = true;
          await handleCanPlay(video);
        } catch (error) {
          handleError(error, $t('errors.unable_to_play_video'));
        }
      };
    
      const onSwipe = (event: SwipeCustomEvent) => {
        if (event.detail.direction === 'left') {
          onNextAsset();
        }
        if (event.detail.direction === 'right') {
          onPreviousAsset();
        }
      };
    
      const startFastForward = () => {
        if (!videoPlayer || isForwarding) return;
        
        isForwarding = true;
        
        if (isRewinding) {
          stopRewind();
        }
        
        if (videoPlayer.paused) {
          videoPlayer.play().catch(error => handleError(error, $t('errors.unable_to_play_video')));
        }
        
        videoPlayer.playbackRate = fastForwardRate;
      };
    
      const stopFastForward = () => {
        if (!videoPlayer || !isForwarding) return;
        
        videoPlayer.playbackRate = normalPlaybackRate;
        isForwarding = false;
      };
    
      const startRewind = () => {
        if (!videoPlayer || isRewinding) return;
        
        isRewinding = true;
        
        if (isForwarding) {
          stopFastForward();
        }
        
        if (videoPlayer.paused) {
          videoPlayer.play().catch(error => handleError(error, $t('errors.unable_to_play_video')));
        }
        
        const rewindStep = 0.1; // Small step for smoother rewind
        rewindInterval = setInterval(() => {
          if (!videoPlayer) return;
          
          const newTime = Math.max(videoPlayer.currentTime - rewindStep, 0);
          videoPlayer.currentTime = newTime;
          
          if (newTime <= 0) {
            stopRewind();
          }
        }, 30); // Update frequently for smoother appearance
      };
    
      const stopRewind = () => {
        if (!isRewinding) return;
        
        if (rewindInterval) {
          clearInterval(rewindInterval);
          rewindInterval = null;
        }
        
        isRewinding = false;
      };
    
      const handleKeydown = (event: KeyboardEvent) => {
        if (!videoPlayer) return;
        
        if (event.key === 'ArrowRight') {
          const skipTime = calculateSkipTime();
          videoPlayer.currentTime = Math.min(videoPlayer.currentTime + skipTime, videoPlayer.duration);
          event.preventDefault();
        }
        else if (event.key === 'ArrowLeft') {
          const skipTime = calculateSkipTime();
          videoPlayer.currentTime = Math.max(videoPlayer.currentTime - skipTime, 0);
          event.preventDefault();
        }
      };
      
      const calculateSkipTime = () => {
        if (!videoPlayer) return 0;
        
        let skipTime = videoPlayer.duration * skipPercentage;
        
        if (skipTime > maxSkipSeconds) {
          skipTime = maxSkipSeconds;
        } else if (skipTime < minSkipSeconds) {
          skipTime = minSkipSeconds;
        }
        
        return skipTime;
      };
      
      const updateProgress = () => {
        if (!videoPlayer) return;
        currentTime = videoPlayer.currentTime;
        duration = videoPlayer.duration || 0;
        progress = duration ? (currentTime / duration) * 100 : 0;
      };
      
      const handleProgressBarClick = (event: MouseEvent) => {
        if (!videoPlayer) return;
        const progressBar = event.currentTarget as HTMLDivElement;
        const rect = progressBar.getBoundingClientRect();
        const clickPosition = (event.clientX - rect.left) / rect.width;
        videoPlayer.currentTime = clickPosition * videoPlayer.duration;
      };
      
      const togglePlayPause = () => {
        if (!videoPlayer) return;
        if (videoPlayer.paused) {
          videoPlayer.play();
        } else {
          videoPlayer.pause();
        }
        
        showControls = true;
        resetControlsTimeout();
      };
      
      const formatTime = (timeInSeconds: number): string => {
        if (isNaN(timeInSeconds)) return '00:00';
        
        const minutes = Math.floor(timeInSeconds / 60);
        const seconds = Math.floor(timeInSeconds % 60);
        
        return `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
      };
      
      const resetControlsTimeout = () => {
        if (controlsTimeout) {
          clearTimeout(controlsTimeout);
        }
        
        controlsTimeout = setTimeout(() => {
          showControls = false;
        }, 3000);
      };
      
      const showVideoControls = () => {
        showControls = true;
        resetControlsTimeout();
      };
    
      const toggleTagsPanel = () => {
        showTagsPanel = !showTagsPanel;
      };
    
      const handleAddTag = () => (isTagFormOpen = true);
    
      const handleCancelTag = () => (isTagFormOpen = false);
    
      const handleTag = async (tagIds: string[]) => {
        if (!asset?.id) return;
        
        const ids = await tagAssets({ tagIds, assetIds: [asset.id], showNotification: false });
        if (ids) {
          isTagFormOpen = false;
        }
    
        asset = await getAssetInfo({ id: asset.id });
        
        if (asset?.tags) {
          selectedPresetTags = asset.tags
            .filter(tag => presetTags.some(preset => preset.value === tag.value))
            .map(tag => tag.value);
        }
      };
    
      const handleRemoveTag = async (tagId: string) => {
        if (!asset?.id) return;
        
        const ids = await removeTag({ tagIds: [tagId], assetIds: [asset.id], showNotification: false });
        if (ids) {
          asset = await getAssetInfo({ id: asset.id });
          
          if (asset?.tags) {
            selectedPresetTags = asset.tags
              .filter(tag => presetTags.some(preset => preset.value === tag.value))
              .map(tag => tag.value);
          }
        }
      };
      
      const togglePresetTag = async (presetTagValue: string) => {
        if (!asset?.id) return;
        
        const existingTag = asset.tags.find(tag => tag.value === presetTagValue);
        
        if (existingTag) {
          await handleRemoveTag(existingTag.id);
        } else {
          
          const tagId = availableTagsMap[presetTagValue.toLowerCase()];
          
          if (tagId) {
            await handleTag([tagId]);
          } else {
            isTagFormOpen = true;
          }
        }
      };
      
      const isPresetTagSelected = (tagValue: string): boolean => {
        return asset?.tags?.some(tag => tag.value === tagValue) || false;
      };
    
      let containerWidth = $state(0);
      let containerHeight = $state(0);
    
      $effect(() => {
        if (isFaceEditMode.value) {
          videoPlayer?.pause();
        }
      });
    </script>
    
    <div
      transition:fade={{ duration: 150 }}
      class="flex flex-col h-full select-none"
    >
      <div 
        class="flex-grow relative flex place-content-center place-items-center"
        bind:clientWidth={containerWidth}
        bind:clientHeight={containerHeight}
        onkeydown={handleKeydown}
        tabindex="0"
        onmousemove={showVideoControls}
        ontouchmove={showVideoControls}
      >
        <video
          bind:this={videoPlayer}
          loop={$loopVideoPreference && loopVideo}
          autoplay
          playsinline
          webkit-playsinline="true"
          class="h-full object-contain"
          use:swipe={() => ({})}
          onswipe={onSwipe}
          ontimeupdate={updateProgress}
          oncanplay={(e) => handleCanPlay(e.currentTarget)}
          onended={onVideoEnded}
          onvolumechange={(e) => {
            if (!forceMuted) {
              $videoViewerMuted = e.currentTarget.muted;
            }
          }}
          onseeking={() => (isScrubbing = true)}
          onseeked={() => (isScrubbing = false)}
          onplaying={(e) => {
            e.currentTarget.focus();
            updateProgress();
          }}
          onclose={() => onClose()}
          muted={forceMuted || $videoViewerMuted}
          bind:volume={$videoViewerVolume}
          poster={getAssetThumbnailUrl({ id: assetId, size: AssetMediaSize.Preview, cacheKey })}
          src={assetFileUrl}
          onclick={togglePlayPause}
        >
        </video>
    
        {#if isLoading}
          <div class="absolute flex place-content-center place-items-center">
            <LoadingSpinner />
          </div>
        {/if}
    
        {#if isFaceEditMode.value}
          <FaceEditor htmlElement={videoPlayer} {containerWidth} {containerHeight} {assetId} />
        {/if}
    
        <!-- Fast Rewind Button -->
        <div class="z-[1001] fixed left-0 bottom-[15%]">
          <button 
            class="bg-transparent text-white rounded-full p-2"
            onmousedown={startRewind}
            onmouseup={stopRewind}
            onmouseleave={stopRewind}
            ontouchstart={startRewind}
            ontouchend={stopRewind}
          >
            ⏪ {isRewinding ? '3.5x' : 'skip'}
          </button>
        </div>
    
        <!-- Fast Forward Button -->
        <div class="z-[1001] fixed left-0 bottom-[88%]">
          <button 
            class="bg-transparent text-white rounded-full p-2"
            onmousedown={startFastForward}
            onmouseup={stopFastForward}
            onmouseleave={stopFastForward}
            ontouchstart={startFastForward}
            ontouchend={stopFastForward}
          >
            {isForwarding ? '3.5x' : 'skip'} ⏩
          </button>
        </div>
        
        <!-- Preset Tags Quick Access Panel - Left side of the video -->
        {#if isOwner && asset?.id && !isSharedLink()}
          <div class="z-[1001] fixed left-2 bottom-77">
            <div class="flex flex-col gap-1">
              {#each presetTags as presetTag (presetTag.id)}
                <button
                  type="button"
                  class={`px-2 py-1 rounded-lg text-white text-opacity-50 transition-all flex items-center gap-1 ${isPresetTagSelected(presetTag.value) ? 'bg-immich-primary' : 'bg-black bg-opacity-5 hover:bg-immich-primary/50'}`}
                  onclick={() => togglePresetTag(presetTag.value)}
                >
                  <Icon path={mdiTag} size="0.6rem" />
                  <span class="text-xs font-medium text-opacity-50">{presetTag.value}</span>
                </button>
              {/each}
            </div>
          </div>
        {/if}
        
        <!-- Custom progress bar - shows only when showControls is true -->
        {#if showControls}
          <div 
            class="absolute bottom-0 left-0 right-0 bg-black bg-opacity-40 px-2 py-1 transition-opacity mx-auto max-w-[80%]"
            transition:fade={{ duration: 150 }}
          >
            <div 
              class="relative h-2 bg-gray-600 rounded cursor-pointer"
              onmousedown={handleProgressBarClick}
              ontouchstart={handleProgressBarClick}
            >
              <div 
                class="absolute top-0 left-0 h-full bg-immich-primary rounded"
                style={`width: ${progress}%`}
              ></div>
            </div>
            
            <!-- Time indicator -->
            <div class="flex justify-between text-xs text-white mt-1">
              <span>{formatTime(currentTime)}</span>
              <span>{formatTime(duration)}</span>
            </div>
          </div>
        {/if}
    
        <!-- Tag Button and Panel section -->
        {#if isOwner && asset?.id && !isSharedLink()}
          <div class="z-[1001] fixed left-0 bottom-[80%]">
            <div class="flex flex-col">
              <!-- Always visible add tag button -->
              <button
                type="button"
                class="bg-immich-primary text-white rounded-full px-3 py-1 mb-2 flex items-center gap-1 hover:bg-immich-primary/80 transition-all"
                title="Add tag"
                onclick={handleAddTag}
              >
                <Icon path={mdiPlus} size="0.75rem" />
                <span class="text-xs">Add Tag</span>
              </button>
              
              <!-- Toggle for existing tags -->
              {#if tags.length > 0}
                <button 
                  type="button"
                  class="bg-black bg-opacity-40 text-white text-opacity-5 rounded-full px-3 py-1 mb-2 flex items-center gap-1"
                  title="Toggle Tags"
                  onclick={toggleTagsPanel}
                >
                  <span class="text-xs text-opacity-5">View Tags {showTagsPanel ? '▲' : '▼'}</span>
                </button>
              {/if}
              
              {#if showTagsPanel && tags.length > 0}
                <!-- Reduced max-width from 300px to 200px -->
                <div class="bg-black bg-opacity-5 rounded p-2 max-w-[200px]">
                  <div class="flex flex-wrap gap-1">
                    {#each tags as tag (tag.id)}
                      <div class="flex group transition-all">
                        <a
                          class="inline-block h-min whitespace-nowrap pl-2 pr-1 py-0.5 text-center align-baseline leading-none text-gray-100 bg-immich-primary rounded-tl-full rounded-bl-full hover:bg-immich-primary/80 transition-all"
                          href={encodeURI(`${AppRoute.TAGS}/?path=${tag.value}`)}
                        >
                          <p class="text-xs text-opacity-50">
                            {tag.value}
                          </p>
                        </a>
    
                        <button
                          type="button"
                          class="text-gray-100 bg-immich-primary/95 rounded-tr-full rounded-br-full place-items-center place-content-center pr-1 pl-0.5 py-0.5 hover:bg-immich-primary/80 transition-all"
                          title="Remove tag"
                          onclick={() => handleRemoveTag(tag.id)}
                        >
                          <Icon path={mdiClose} size="0.75rem" />
                        </button>
                      </div>
                    {/each}
                  </div>
                </div>
              {/if}
            </div>
          </div>
        {/if}
      </div>
    
    {#if isTagFormOpen}
      <Portal>
        <TagAssetForm onTag={(tagsIds) => handleTag(tagsIds)} onCancel={handleCancelTag} />
      </Portal>
    {/if}
++ b/web/src/lib/stores/assets-store.svelte.ts










  tagIds?: string[];  // Add this
  isFavorite?: boolean; // Add this









  

    const params = new URLSearchParams();

    if (this.#options.albumId) {
      params.append('albumId', this.#options.albumId);
    }
    if (this.#options.personId) {
      params.append('personId', this.#options.personId);
    }
    if (this.#options.isArchived !== undefined) {
      params.append('isArchived', String(this.#options.isArchived));
    }
    if (this.#options.isFavorite !== undefined) {
      params.append('isFavorite', String(this.#options.isFavorite));
    }
    if (this.#options.isTrashed !== undefined) {
      params.append('isTrashed', String(this.#options.isTrashed));
    }
  
    if (this.#options.tagIds && this.#options.tagIds.length > 0) {
      this.#options.tagIds.forEach(tagId => {
        params.append('tagIds', tagId);
      });
    }
    
    console.log("Updating options with:", JSON.stringify(options));

    console.log("Initializing asset store with options:", JSON.stringify(options));


  
++ b/web/src/routes/(user)/albums/[albumId=id]/[[photos=photos]]/[[assetId=id]]/+page.svelte






  import Combobox from '$lib/components/shared-components/combobox.svelte';
  import { SvelteSet } from 'svelte/reactivity';
  import FilterBar from '$lib/components/shared-components/filter-bar.svelte'; // You may need

    let selectedTags = $state(new SvelteSet<string>());
    let isStarred = $state(false);




































$effect(() => {
  if (viewMode === AlbumPageViewMode.VIEW) {
    const tagIdsArray = selectedTags.size > 0 ? Array.from(selectedTags) : undefined;
    console.log("Selected tags updated in album page:", tagIdsArray);

    console.log("Updating asset store with filters:", {
      albumId,
      tagIds: tagIdsArray,
      isFavorite: isStarred
    });
    
      void assetStore.updateOptions({ 
      albumId, 
      order: albumOrder,
      tagIds: tagIdsArray,
      isFavorite: isStarred
    });
  } else if (viewMode === AlbumPageViewMode.SELECT_ASSETS) {
    void assetStore.updateOptions({ isArchived: false, withPartners: true, timelineAlbumId: albumId });
  }
});

















          <!-- 888999888 -->
          {#if album.assetCount > 0 && viewMode === AlbumPageViewMode.VIEW}
            <section class="mt-4">
              <FilterBar bind:selectedTags bind:isStarred />
            </section>
          {/if}






